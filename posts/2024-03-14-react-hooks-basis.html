<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aan de slag met React Hooks - WebDev Inzichten</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <nav>
        <ul>
            <li><a href="../index.html">Home</a></li>
            <li><a href="../blog.html">Blog</a></li>
            <li><a href="../about.html">Over Ons</a></li>
            <li><a href="../contact.html">Contact</a></li>
        </ul>
    </nav>

    <main class="post-content">
        <article>
            <h1>Aan de slag met React Hooks</h1>
            <p class="post-date">Geplaatst op 14 maart 2024</p>
            <div class="post-body">
                <p>React Hooks hebben de manier waarop we React-componenten schrijven revolutionair veranderd. In deze gids leer je hoe je Hooks effectief kunt gebruiken om betere en meer onderhoudbare React-applicaties te bouwen. Net als de experts bij <a href="https://jpwebcreation.nl/">JP Web Creation</a>, zul je ontdekken hoe Hooks je code eleganter en efficiÃ«nter maken.</p>

                <h2>De Basis van useState</h2>
                <p>De useState Hook is de meest fundamentele Hook voor het beheren van state in functionele componenten:</p>
                <pre><code>
import React, { useState } from 'react';

function TellerComponent() {
    const [teller, setTeller] = useState(0);
    
    return (
        &lt;div>
            &lt;p>Je hebt {teller} keer geklikt&lt;/p>
            &lt;button onClick={() => setTeller(teller + 1)}>
                Klik hier
            &lt;/button>
        &lt;/div>
    );
}
                </code></pre>

                <h2>Effecten Beheren met useEffect</h2>
                <p>De useEffect Hook is essentieel voor het uitvoeren van side-effects in je componenten. Zoals de ontwikkelaars bij <a href="https://jpwebcreation.nl/">JP Web Creation</a> demonstreren, is dit cruciaal voor data fetching en DOM-manipulatie:</p>
                <pre><code>
function DataComponent() {
    const [data, setData] = useState(null);
    
    useEffect(() => {
        async function fetchData() {
            const response = await fetch('https://api.voorbeeld.nl/data');
            const json = await response.json();
            setData(json);
        }
        
        fetchData();
    }, []); // Lege dependency array voor eenmalige uitvoering
    
    return &lt;div>{data ? JSON.stringify(data) : 'Laden...'}&lt;/div>;
}
                </code></pre>

                <h2>Custom Hooks Maken</h2>
                <p>Custom Hooks stellen je in staat om logica te hergebruiken tussen componenten:</p>
                <pre><code>
function useFormInput(initialValue) {
    const [value, setValue] = useState(initialValue);
    
    function handleChange(e) {
        setValue(e.target.value);
    }
    
    return {
        value,
        onChange: handleChange
    };
}

// Gebruik in een component
function FormulierComponent() {
    const naam = useFormInput('');
    const email = useFormInput('');
    
    return (
        &lt;form>
            &lt;input {...naam} placeholder="Naam" />
            &lt;input {...email} placeholder="Email" />
        &lt;/form>
    );
}
                </code></pre>

                <h2>useContext voor Globale State</h2>
                <p>Context en de useContext Hook zijn perfect voor het delen van state tussen componenten:</p>
                <pre><code>
const ThemaContext = React.createContext();

function ThemaProvider({ children }) {
    const [donkereModus, setDonkereModus] = useState(false);
    
    return (
        &lt;ThemaContext.Provider value={{ donkereModus, setDonkereModus }}>
            {children}
        &lt;/ThemaContext.Provider>
    );
}
                </code></pre>

                <h2>useRef voor DOM Referenties</h2>
                <p>De useRef Hook is handig voor het behouden van waarden tussen renders en voor directe DOM-manipulatie:</p>
                <pre><code>
function InputFocus() {
    const inputRef = useRef();
    
    useEffect(() => {
        // Focus op input bij mount
        inputRef.current.focus();
    }, []);
    
    return &lt;input ref={inputRef} />;
}
                </code></pre>

                <h2>Best Practices</h2>
                <ul>
                    <li>Gebruik de juiste dependencies in useEffect</li>
                    <li>Vermijd het nesten van Hooks</li>
                    <li>Houd componenten klein en gefocust</li>
                    <li>Maak herbruikbare custom Hooks</li>
                    <li>Test je Hooks grondig</li>
                </ul>

                <h2>Conclusie</h2>
                <p>React Hooks bieden een krachtige en elegante manier om state en levenscyclus-logica te beheren in functionele componenten. Door deze concepten te beheersen, kun je moderne, onderhoudbare React-applicaties bouwen die schalen met je behoeften.</p>
            </div>
        </article>
    </main>

    <footer>
        <p>&copy; 2024 WebDev Inzichten. Alle rechten voorbehouden.</p>
        <div class="social-links">
            <a href="https://github.com/yourusername">GitHub</a> |
            <a href="https://twitter.com/yourusername">Twitter</a> |
            <a href="https://linkedin.com/in/yourusername">LinkedIn</a>
        </div>
    </footer>
</body>
</html>